import {
  getDoc,
  onSnapshot,
  Firestore,
  doc,
  QueryDocumentSnapshot,
  SnapshotOptions,
  collection,
  setDoc,
  getDocs,
  updateDoc as firestoreUpdateDoc,
  deleteDoc as firestoreDeleteDoc,
  query,
  where as firestoreWhere,
  orderBy as firestoreOrderBy,
  QueryConstraint,
  addDoc,
  UpdateData,
  Timestamp,
} from "firebase/firestore";
import { z } from "zod";
import { ExtendedSchema } from "./types";

function deepReplaceDate<T extends Timestamp>(input: T): string;
function deepReplaceDate<T>(input: T): T;
function deepReplaceDate(input: any): any {
  if (input === null) return input;
  if (input instanceof Timestamp) return input.toDate();
  if (typeof input !== "object") return input;
  if (Array.isArray(input)) return input.map(deepReplaceDate);
  return Object.keys(input).reduce(
    (acc, k) => ({
      ...acc,
      [k]: deepReplaceDate(input[k]),
    }),
    {}
  );
}

type DocChange<DocumentData> =
  | { type: "added"; doc: DocumentData }
  | {
      type: "modified";
      doc: DocumentData;
    }
  | { type: "removed"; docId: string };

const validationConverter = <Schema extends ExtendedSchema>(
  validationSchema: Schema
) => {
  return {
    toFirestore(data: z.infer<Schema>) {
      // remove docId before saving
      const { docId, ...rest } = data;

      // validate the data
      const parsed = validationSchema.safeParse(rest);
      if (!parsed.success)
        throw new Error(`Invalid data: ${parsed.error.format()}`);

      // return the parsed data
      return parsed.data;
    },
    fromFirestore(
      snapshot: QueryDocumentSnapshot,
      options?: SnapshotOptions
    ): z.infer<Schema> | null {
      const data = snapshot.data(options || { serverTimestamps: "estimate" });
      const parsed = validationSchema.safeParse(deepReplaceDate(data));
      if (parsed.success) {
        if (parsed.data.hasOwnProperty("docId"))
          console.warn("docId already exists in DB");

        // add docId to the parsed object (consider docId as a reserved keyword - do not add to schema)
        return { ...parsed.data, docId: snapshot.id };
      }
      console.error(`Failed to validate data`, data, parsed.error);
      return null;
    },
  };
};


type NonArrayOperator = "<" | "<=" | "==" | ">" | ">=" | "!=" | "in" | "not-in";
type ArrayOperator = "array-contains" | "array-contains-any";
type DotPrefix<T extends string> = T extends "" ? "" : `.${T}`;

type DotNestedKeys<T> = T extends Date | Function | Array<any>
  ? ""
  : (
      T extends object
        ? {
            [K in Exclude<keyof T, symbol>]: `${K}${DotPrefix<
              DotNestedKeys<T[K]>
            >}`;
          }[Exclude<keyof T, symbol>]
        : ""
    ) extends infer D
  ? Extract<D, string>
  : never;

const buildQueryContrains = <Data extends { [key: string]: any }>(
  where?: Array<[DotNestedKeys<Data>, NonArrayOperator | ArrayOperator, any]>,
  orderBy?: Array<{
    key: DotNestedKeys<Data>;
    direction?: "asc" | "desc";
  }>
) => {
  const queryConstraints: QueryConstraint[] = [];

  // add where constraints
  where = where || [];
  for (const whereCondition of where) {
    queryConstraints.push(firestoreWhere(...whereCondition));
  }

  // add order by constraints
  orderBy = orderBy || [];
  for (const orderByCondition of orderBy) {
    queryConstraints.push(
      firestoreOrderBy(orderByCondition.key, orderByCondition.direction)
    );
  }

  return queryConstraints;
};

export class DocumentCollection<Schema extends ExtendedSchema> {
  readonly collectionId: string;
  readonly firestore: Firestore;
  readonly validationSchema: Schema;

  constructor({
    collectionId,
    firestore,
    validationSchema,
  }: {
    readonly collectionId: string;
    readonly firestore: Firestore;
    readonly validationSchema: Schema;
  }) {
    this.collectionId = collectionId;
    this.firestore = firestore;
    this.validationSchema = validationSchema;
  }

  async getDocument(docId: string) {
    const docPath = `${this.collectionId}/${docId}`;
    const snapshot = await getDoc(
      doc(this.firestore, docPath).withConverter(
        validationConverter(this.validationSchema)
      )
    );
    if (snapshot.exists()) {
      return snapshot.data();
    } else {
      return null;
    }
  }

  /**
   * Save a document to the collection
   *
   * @param docId if `docId` is not provided (ie. is `null`), an autogenerated id will be used
   * @param data
   * @returns
   */
  async submitDoc(docId: string | null, data: z.infer<Schema>) {
    if (!docId) {
      // auto generate id
      return await addDoc(
        collection(this.firestore, this.collectionId).withConverter(
          validationConverter(this.validationSchema)
        ),
        data
      );
    } else {
      // use provided id
      return await setDoc(
        doc(this.firestore, `${this.collectionId}/${docId}`).withConverter(
          validationConverter(this.validationSchema)
        ),
        data
      );
    }
  }

  async updateDoc(docId: string, data: UpdateData<z.infer<Schema>>) {
    return await firestoreUpdateDoc(
      doc(this.firestore, `${this.collectionId}/${docId}`).withConverter(
        validationConverter(this.validationSchema)
      ),
      data
    );
  }

  async deleteDoc(docId: string) {
    return await firestoreDeleteDoc(
      doc(this.firestore, `${this.collectionId}/${docId}`)
    );
  }

  watchDocument({
    docId,
    onChange,
    onError,
  }: {
    docId: string;
    onChange: (data: z.infer<Schema> | null) => void;
    onError: (error: Error) => void;
  }) {
    const docPath = `${this.collectionId}/${docId}`;
    return onSnapshot(
      doc(this.firestore, docPath).withConverter(
        validationConverter(this.validationSchema)
      ),
      {
        next: (snapshot) => {
          onChange(snapshot.exists() ? snapshot.data() : null);
        },
        error: onError,
      }
    );
  }

  async getCollection({
    where,
    orderBy,
  }: {
    where?: Array<
      [DotNestedKeys<z.infer<Schema>>, NonArrayOperator | ArrayOperator, any]
    >;
    orderBy?: Array<{
      key: DotNestedKeys<z.infer<Schema>>;
      direction?: "asc" | "desc";
    }>;
    onChange: (data: z.infer<Schema>[] | null) => void;
    onError: (error: Error) => void;
  }) {
    const docPath = `${this.collectionId}`;

    const q = query(
      collection(this.firestore, docPath),
      ...buildQueryContrains<z.infer<Schema>>(where, orderBy)
    ).withConverter(validationConverter(this.validationSchema));
    const snapshot = await getDocs(q);
    return snapshot.docs.map((doc) => doc.data());
  }

  /**
   * Watch a collection for changes.
   * You can use only the changes (`changes`) or use all docs (`docs`) for the query on each change.
   * You can specify `where` and `orderBy` to define a query to fit your needs.
   */
  watchCollection({
    onChange,
    onError,
    options,
  }: {
    onChange: ({
      docs,
      changes,
    }: {
      docs: z.infer<Schema>[];
      changes: DocChange<z.infer<Schema>>[];
    }) => void;
    onError?: (error: Error) => void;
    options?: {
      where?: Array<
        [DotNestedKeys<z.infer<Schema>>, NonArrayOperator | ArrayOperator, any]
      >;
      orderBy?: Array<{
        key: DotNestedKeys<z.infer<Schema>>;
        direction?: "asc" | "desc";
      }>;
    };
  }) {
    const docPath = `${this.collectionId}`;

    const q = query(
      collection(this.firestore, docPath),
      ...buildQueryContrains<z.infer<Schema>>(options?.where, options?.orderBy)
    ).withConverter(validationConverter(this.validationSchema));
    return onSnapshot(q, {
      next: (snapshot) => {
        return onChange({
          docs: snapshot.docs.map((doc) => doc.data()!),
          changes: snapshot.docChanges().map((change) => {
            switch (change.type) {
              case "added":
                return {
                  type: "added",
                  doc: change.doc.data()!,
                };
              case "modified":
                return {
                  type: "modified",
                  doc: change.doc.data()!,
                };
              case "removed":
                return { type: "removed", docId: change.doc.id };
              default:
                throw new Error(`unexpected change type: ${change.type}`);
            }
          }),
        });
      },
      error: onError,
    });
  }
}
